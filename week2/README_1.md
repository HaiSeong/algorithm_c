# [ 문제 1 ] (선택 정렬) n개의 양의 정수(중복 가능)를 입력받아, 아래에서 설명하는 선택 정렬을 이용하여 정렬하는 프로그램을 작성하시오.

### 구현해야 할 선택 정렬 알고리즘 (가장 큰 값을 찾는 버전):
- 크기가 n인 배열을 동적 할당하여, 입력된 양의 정수 저장(입력 정수는 중복 가능)
- 제자리(in place) 정렬 사용. 즉, 입력 값 저장을 위한 배열 이외에 O(1)의 추가 공간만 사용
- 배열의 뒷 부분을 정렬 상태로 유지하고, 매 반복마다 최대 한 번의 교환 연산만 사용
(매 반복마다 가장 큰 값을 찾아, 오른쪽부터 채우는 방식으로 정렬) - 가능하면 교재의 의사코드를 보지 말고 구현해볼 것을 권장
- 참고: 아래 그림에 예시된 버전은 매 반복마다 가장 큰 값을 찾아 배열의 오른쪽부터 채워
나가는, 즉 교재의 알고리즘과는 정반대 방향으로 작동하는 버전이다. 어느 방향으로
구현하더라도 무방하다.

<br>

### 알고리즘 동작 과정 예시 (n = 8)
	초기 상태: 8 31 48 73 3 65 20 29
	1번째 반복 후: 8 31 48 29 3 65 20 73 (73과 29 교환)
	2번째 반복 후: 8 31 48 29 3 20 65 73 (65와 20 교환)
	3번째 반복 후: 8 31 20 29 3 48 65 73 (48과 20 교환)
	4번째 반복 후: 8 3 20 29 31 48 65 73 (31과 3 교환)
	5번째 반복 후: 8 3 20 29 31 48 65 73 (29 제자리 교환)
	6번째 반복 후: 8 3 20 29 31 48 65 73 (20 제자리 교환)
	7번째 반복 후: 3 8 20 29 31 48 65 73 (8과 3 교환)

<br>

| 입력 예시 1 | 출력 예시 1 |
|:--|:--|
|8<br>8 31 48 73 3 65 20 29 | 3 8 20 29 31 48 65 73 |
|8<br>73 65 48 31 29 20 8 3 | 3 8 20 29 31 48 65 73 |

<br>

### initList
- 인자 n을 받아 n크기의 배열을 동적할당 해줌
- 할당 실패시 NULL 리턴
<br><br>

### listSize
- 리스트의 크기를 리턴한다.
<br><br>

### isEmpty
- 리스트가 비어있으면 1을 리턴한다..
<br><br>

### isFull
- 리스트가 꽉차있으면 1을 리턴한다.
<br><br>

### insertItem
- 리스트의 맨 뒤에 원소를 추가한다.
- 리스트가 꽉차있으면 실행하지 않는다.
<br><br>

### removeMin
- 리스트에서 가장 작은 숫자의 인덱스를 찾음
- 가장 작은 숫자를 마지막 숫자와 위치를 바꾸고 사이즈를 하나 감소
- 삭제된 원소를 리턴
<br><br>

### freeList
- 할당받은 메모리를 반환한다.
<br><br>
